# PSIæ ‘æ·±åº¦è§£æï¼ˆå››ï¼‰ï¼šä¸Stubç´¢å¼•çš„é›†æˆ

## ğŸ¯ å¼•è¨€

åœ¨å‰é¢çš„æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬åˆ†åˆ«ä»‹ç»äº†PSIæ ‘å’ŒStubç´¢å¼•çš„è®¾è®¡å®ç°ã€‚æœ¬æ–‡å°†æ·±å…¥æ¢è®¨è¿™ä¸¤ç§æŠ€æœ¯çš„é›†æˆï¼Œä»¥åŠå¦‚ä½•æ„å»ºä¸€ä¸ªç»Ÿä¸€çš„ä»£ç åˆ†æå¹³å°ã€‚é€šè¿‡å°†PSIæ ‘çš„ä¸°å¯Œè¯­ä¹‰ä¿¡æ¯ä¸Stubç´¢å¼•çš„é«˜æ•ˆæŸ¥è¯¢èƒ½åŠ›ç»“åˆï¼Œæˆ‘ä»¬å¯ä»¥å®ç°æ›´å¼ºå¤§çš„ä»£ç åˆ†æåŠŸèƒ½ã€‚

## ğŸ”„ é›†æˆæ¶æ„è®¾è®¡

### æ•´ä½“æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 ç»Ÿä¸€APIå±‚                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ æŸ¥è¯¢æ¥å£    â”‚  â”‚ åˆ†ææ¥å£    â”‚  â”‚ é‡æ„æ¥å£ â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚               åŒæ­¥ç®¡ç†å±‚                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ æ•°æ®åŒæ­¥    â”‚  â”‚ ç´¢å¼•æ›´æ–°    â”‚  â”‚ ç¼“å­˜ç®¡ç† â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚              æ ¸å¿ƒç»„ä»¶å±‚                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚   PSIæ ‘     â”‚  â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚  Stubç´¢å¼•   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                æ•°æ®æŒä¹…å±‚                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  æ–‡ä»¶å­˜å‚¨   â”‚  â”‚  å†…å­˜ç¼“å­˜   â”‚  â”‚ ç´¢å¼•å­˜å‚¨ â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### é›†æˆç­–ç•¥

1. **åŒå‘åŒæ­¥**: PSIæ ‘å’ŒStubç´¢å¼•ä¹‹é—´ä¿æŒæ•°æ®ä¸€è‡´æ€§
2. **æŸ¥è¯¢ç»Ÿä¸€**: æä¾›ç»Ÿä¸€çš„æŸ¥è¯¢æ¥å£ï¼Œå±è”½åº•å±‚å®ç°å·®å¼‚
3. **æ€§èƒ½ä¼˜åŒ–**: æ ¹æ®æŸ¥è¯¢ç‰¹ç‚¹è‡ªåŠ¨é€‰æ‹©æœ€ä¼˜çš„æ•°æ®ç»“æ„
4. **å¢é‡æ›´æ–°**: æ”¯æŒä»£ç å˜æ›´æ—¶çš„å¢é‡åŒæ­¥

## ğŸ”— æ•°æ®åŒæ­¥æœºåˆ¶

### åŒå‘æ˜ å°„å™¨

```cpp
class PSITreeStubMapper {
public:
    // PSIèŠ‚ç‚¹åˆ°Stubæ¡ç›®çš„æ˜ å°„
    struct NodeToStubMapping {
        PSINode* psi_node;
        std::shared_ptr<StubEntry> stub_entry;
        std::string mapping_type; // "class", "function", "variable"
        bool is_bidirectional;   // æ˜¯å¦æ”¯æŒåŒå‘æŸ¥æ‰¾
    };

    // æ„å»ºæ˜ å°„å…³ç³»
    std::vector<NodeToStubMapping> buildMappings(PSINode* psi_root, const StubIndex& stub_index);

    // åŒå‘æŸ¥æ‰¾
    std::shared_ptr<StubEntry> findStubEntry(PSINode* psi_node);
    PSINode* findPSINode(std::shared_ptr<StubEntry> stub_entry, PSINode* psi_root);

    // åŒæ­¥æ›´æ–°
    void syncPSIToStub(PSINode* psi_node, StubIndex& stub_index);
    void syncStubToPSI(std::shared_ptr<StubEntry> stub_entry, PSINode* psi_root);

private:
    std::unordered_map<PSINode*, std::shared_ptr<StubEntry>> node_to_stub_map_;
    std::unordered_map<std::shared_ptr<StubEntry>, PSINode*> stub_to_node_map_;
};
```

### æ˜ å°„æ„å»ºå®ç°

```cpp
std::vector<PSITreeStubMapper::NodeToStubMapping>
PSITreeStubMapper::buildMappings(PSINode* psi_root, const StubIndex& stub_index) {
    std::vector<NodeToStubMapping> mappings;
    PSITreeOperations ops;

    // æ¸…é™¤ç°æœ‰æ˜ å°„
    node_to_stub_map_.clear();
    stub_to_node_map_.clear();

    // æŒ‰ç±»å‹æ„å»ºæ˜ å°„
    auto class_mappings = buildClassMappings(psi_root, stub_index);
    auto function_mappings = buildFunctionMappings(psi_root, stub_index);
    auto variable_mappings = buildVariableMappings(psi_root, stub_index);

    // åˆå¹¶æ‰€æœ‰æ˜ å°„
    mappings.insert(mappings.end(), class_mappings.begin(), class_mappings.end());
    mappings.insert(mappings.end(), function_mappings.begin(), function_mappings.end());
    mappings.insert(mappings.end(), variable_mappings.begin(), variable_mappings.end());

    return mappings;
}

std::vector<PSITreeStubMapper::NodeToStubMapping>
PSITreeStubMapper::buildClassMappings(PSINode* psi_root, const StubIndex& stub_index) {
    std::vector<NodeToStubMapping> mappings;
    PSITreeOperations ops;

    // è·å–PSIæ ‘ä¸­çš„æ‰€æœ‰ç±»èŠ‚ç‚¹
    auto psi_classes = ops.findAllNodes(psi_root, PSINodeType::CLASS);

    // è·å–Stubç´¢å¼•ä¸­çš„æ‰€æœ‰ç±»æ¡ç›®
    auto stub_classes = stub_index.queryByType(StubType::CLASS);

    // æŒ‰åç§°åŒ¹é…
    for (auto* psi_class : psi_classes) {
        std::string class_name = psi_class->getText();

        for (auto& stub_class : stub_classes.entries) {
            if (stub_class->getName() == class_name) {
                NodeToStubMapping mapping;
                mapping.psi_node = psi_class;
                mapping.stub_entry = stub_class;
                mapping.mapping_type = "class";
                mapping.is_bidirectional = true;

                mappings.push_back(mapping);
                node_to_stub_map_[psi_class] = stub_class;
                stub_to_node_map_[stub_class] = psi_class;

                // åŒæ­¥ä½ç½®ä¿¡æ¯
                syncLocationInfo(psi_class, stub_class);
                break;
            }
        }
    }

    return mappings;
}

void PSITreeStubMapper::syncLocationInfo(PSINode* psi_node, std::shared_ptr<StubEntry> stub_entry) {
    // åŒæ­¥æ–‡ä»¶è·¯å¾„
    auto psi_location = psi_node->getLocation();
    auto stub_location = stub_entry->getLocation();

    if (psi_location.file_path != stub_location.file_path) {
        // ä¼˜å…ˆä½¿ç”¨PSIæ ‘çš„æ–‡ä»¶è·¯å¾„ï¼ˆæ›´å‡†ç¡®ï¼‰
        auto* mutable_stub = const_cast<StubEntry*>(stub_entry.get());
        auto* mutable_location = const_cast<SourceLocation*>(&mutable_stub->getLocation());
        const_cast<std::string&>(mutable_location->file_path) = psi_location.file_path;
    }

    // åŒæ­¥è¡Œå·ä¿¡æ¯
    if (psi_location.line != stub_location.line) {
        auto* mutable_stub = const_cast<StubEntry*>(stub_entry.get());
        auto* mutable_location = const_cast<SourceLocation*>(&mutable_stub->getLocation());
        const_cast<int&>(mutable_location->line) = psi_location.line;
    }
}
```

## ğŸ”„ å¢é‡åŒæ­¥ç³»ç»Ÿ

### åŒæ­¥ç®¡ç†å™¨

```cpp
class IncrementalSyncManager {
public:
    struct ChangeInfo {
        enum Type { INSERT, DELETE, MODIFY, MOVE };
        Type type;
        std::string file_path;
        SourceLocation location;
        size_t length;
        std::string old_content;
        std::string new_content;
    };

    // åˆ†æä»£ç å˜æ›´
    std::vector<ChangeInfo> analyzeChanges(const std::string& old_content,
                                          const std::string& new_content,
                                          const std::string& file_path);

    // åº”ç”¨å¢é‡åŒæ­¥
    void applyChanges(PSINode* psi_root,
                     StubIndex& stub_index,
                     const std::vector<ChangeInfo>& changes);

    // éªŒè¯åŒæ­¥ä¸€è‡´æ€§
    bool validateConsistency(PSINode* psi_root, const StubIndex& stub_index);

private:
    PSITreeStubMapper mapper_;
    PSITreeBuilder psi_builder_;
    StubParser stub_parser_;
};
```

### å¢é‡æ›´æ–°å®ç°

```cpp
void IncrementalSyncManager::applyChanges(PSINode* psi_root,
                                        StubIndex& stub_index,
                                        const std::vector<ChangeInfo>& changes) {
    for (const auto& change : changes) {
        switch (change.type) {
            case ChangeInfo::INSERT:
                handleInsert(psi_root, stub_index, change);
                break;
            case ChangeInfo::DELETE:
                handleDelete(psi_root, stub_index, change);
                break;
            case ChangeInfo::MODIFY:
                handleModify(psi_root, stub_index, change);
                break;
            case ChangeInfo::MOVE:
                handleMove(psi_root, stub_index, change);
                break;
        }
    }

    // é‡æ–°æ„å»ºæ˜ å°„å…³ç³»
    mapper_.buildMappings(psi_root, stub_index);
}

void IncrementalSyncManager::handleInsert(PSINode* psi_root,
                                         StubIndex& stub_index,
                                         const ChangeInfo& change) {
    // è§£ææ–°å¢çš„ä»£ç æ®µ
    StubParser parser;
    auto parse_result = parser.parseCode(change.new_content, change.file_path);
    auto new_stubs = parse_result.getEntries();

    // å°†æ–°çš„Stubæ¡ç›®æ·»åŠ åˆ°ç´¢å¼•
    for (const auto& stub : new_stubs) {
        stub_index.addEntry(stub);
    }

    // æ›´æ–°PSIæ ‘ï¼ˆç®€åŒ–ç‰ˆï¼šé‡æ–°æ„å»ºå—å½±å“çš„éƒ¨åˆ†ï¼‰
    updatePSITreeForInsert(psi_root, change);
}

void IncrementalSyncManager::handleModify(PSINode* psi_root,
                                         StubIndex& stub_index,
                                         const ChangeInfo& change) {
    // æŸ¥æ‰¾å—å½±å“çš„èŠ‚ç‚¹
    PSITreeOperations ops;
    auto affected_nodes = ops.findNodesInLineRange(psi_root,
                                                  change.location.line,
                                                  change.location.line + 10); // ä¼°ç®—å½±å“èŒƒå›´

    // åˆ é™¤æ—§çš„Stubæ¡ç›®
    for (auto* node : affected_nodes) {
        auto stub_entry = mapper_.findStubEntry(node);
        if (stub_entry) {
            stub_index.removeEntry(stub_entry);
        }
    }

    // è§£æä¿®æ”¹åçš„ä»£ç 
    StubParser parser;
    auto parse_result = parser.parseCode(change.new_content, change.file_path);
    auto updated_stubs = parse_result.getEntries();

    // æ·»åŠ æ–°çš„Stubæ¡ç›®
    for (const auto& stub : updated_stubs) {
        stub_index.addEntry(stub);
    }

    // æ›´æ–°PSIæ ‘
    updatePSITreeForModify(psi_root, change);
}
```

## ğŸ¯ ç»Ÿä¸€æŸ¥è¯¢æ¥å£

### ç»Ÿä¸€æŸ¥è¯¢å¼•æ“

```cpp
class UnifiedQueryEngine {
public:
    // ç»Ÿä¸€æŸ¥è¯¢ç»“æœ
    struct UnifiedResult {
        std::vector<PSINode*> psi_nodes;
        std::vector<std::shared_ptr<StubEntry>> stub_entries;
        std::vector<UnifiedMapping> mappings;
    };

    struct UnifiedMapping {
        PSINode* psi_node;
        std::shared_ptr<StubEntry> stub_entry;
        double confidence; // åŒ¹é…ç½®ä¿¡åº¦
    };

    // ç»Ÿä¸€æŸ¥è¯¢æ–¹æ³•
    UnifiedResult queryByName(const std::string& name);
    UnifiedResult queryByType(const std::string& type);
    UnifiedResult queryByFile(const std::string& file_path);
    UnifiedResult queryByCondition(const std::function<bool(const UnifiedMapping&)>& condition);

    // é«˜çº§æŸ¥è¯¢
    UnifiedResult queryInheritanceHierarchy(const std::string& class_name);
    UnifiedResult queryFunctionCalls(const std::string& function_name);
    UnifiedResult queryVariableReferences(const std::string& variable_name);

private:
    PSINode* psi_root_;
    StubIndex* stub_index_;
    PSITreeStubMapper mapper_;
};
```

### æŸ¥è¯¢å®ç°

```cpp
UnifiedQueryEngine::UnifiedResult
UnifiedQueryEngine::queryByName(const std::string& name) {
    UnifiedResult result;

    // å¹¶è¡ŒæŸ¥è¯¢PSIæ ‘å’ŒStubç´¢å¼•
    auto psi_nodes = PSITreeOperations().findAllNodes(psi_root_, PSINodeType::NAMESPACE);
    psi_nodes.erase(std::remove_if(psi_nodes.begin(), psi_nodes.end(),
        [&name](PSINode* node) {
            return node->getText() != name;
        }), psi_nodes.end());

    auto stub_entries = stub_index_->queryByName(name);

    // æ„å»ºç»Ÿä¸€æ˜ å°„
    std::unordered_set<PSINode*> matched_psi_nodes;
    std::unordered_set<std::shared_ptr<StubEntry>> matched_stub_entries;

    for (auto* psi_node : psi_nodes) {
        for (auto& stub_entry : stub_entries.entries) {
            if (isCompatibleMapping(psi_node, stub_entry)) {
                UnifiedMapping mapping;
                mapping.psi_node = psi_node;
                mapping.stub_entry = stub_entry;
                mapping.confidence = calculateConfidence(psi_node, stub_entry);

                result.mappings.push_back(mapping);
                matched_psi_nodes.insert(psi_node);
                matched_stub_entries.insert(stub_entry);
            }
        }
    }

    // æ·»åŠ æœªåŒ¹é…çš„PSIèŠ‚ç‚¹
    for (auto* psi_node : psi_nodes) {
        if (matched_psi_nodes.find(psi_node) == matched_psi_nodes.end()) {
            result.psi_nodes.push_back(psi_node);
        }
    }

    // æ·»åŠ æœªåŒ¹é…çš„Stubæ¡ç›®
    for (auto& stub_entry : stub_entries.entries) {
        if (matched_stub_entries.find(stub_entry) == matched_stub_entries.end()) {
            result.stub_entries.push_back(stub_entry);
        }
    }

    // æŒ‰ç½®ä¿¡åº¦æ’åº
    std::sort(result.mappings.begin(), result.mappings.end(),
        [](const UnifiedMapping& a, const UnifiedMapping& b) {
            return a.confidence > b.confidence;
        });

    return result;
}

UnifiedQueryEngine::UnifiedResult
UnifiedQueryEngine::queryFunctionCalls(const std::string& function_name) {
    UnifiedResult result;

    // åœ¨PSIæ ‘ä¸­æŸ¥æ‰¾å‡½æ•°è°ƒç”¨
    auto psi_nodes = PSITreeOperations().findNodesByCondition(psi_root_,
        [&function_name](PSINode* node) {
            return node->getSemanticInfo("calls").find(function_name) != std::string::npos;
        });

    // åœ¨Stubç´¢å¼•ä¸­æŸ¥æ‰¾è°ƒç”¨å…³ç³»
    auto call_graph = PSITreeAnalyzer().buildCallGraph(psi_root_);
    auto it = call_graph.find(function_name);
    if (it != call_graph.end()) {
        // æŸ¥æ‰¾è°ƒç”¨æ­¤å‡½æ•°çš„å‡½æ•°
        for (const auto& caller : it->second) {
            auto caller_result = queryByName(caller);
            result.mappings.insert(result.mappings.end(),
                                  caller_result.mappings.begin(),
                                  caller_result.mappings.end());
        }
    }

    return result;
}
```

## ğŸš€ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### æ™ºèƒ½è·¯ç”±å™¨

```cpp
class QueryRouter {
public:
    enum class QueryType {
        SIMPLE_LOOKUP,      // ç®€å•æŸ¥æ‰¾ï¼šä½¿ç”¨Stubç´¢å¼•
        SEMANTIC_QUERY,     // è¯­ä¹‰æŸ¥è¯¢ï¼šä½¿ç”¨PSIæ ‘
        RELATIONSHIP_QUERY, // å…³ç³»æŸ¥è¯¢ï¼šç»“åˆä½¿ç”¨
        ANALYSIS_QUERY      // åˆ†ææŸ¥è¯¢ï¼šä½¿ç”¨PSIæ ‘
    };

    // æ ¹æ®æŸ¥è¯¢ç‰¹å¾é€‰æ‹©æœ€ä¼˜çš„æŸ¥è¯¢ç­–ç•¥
    QueryType analyzeQuery(const QueryDescriptor& query) {
        if (query.is_simple_name_lookup && !query.requires_semantic_info) {
            return QueryType::SIMPLE_LOOKUP;
        }

        if (query.requires_hierarchy_info || query.requires_semantic_info) {
            return QueryType::SEMANTIC_QUERY;
        }

        if (query.involves_relationships) {
            return QueryType::RELATIONSHIP_QUERY;
        }

        return QueryType::ANALYSIS_QUERY;
    }

    // æ‰§è¡ŒæŸ¥è¯¢
    UnifiedResult executeQuery(const QueryDescriptor& query) {
        auto query_type = analyzeQuery(query);

        switch (query_type) {
            case QueryType::SIMPLE_LOOKUP:
                return executeSimpleLookup(query);
            case QueryType::SEMANTIC_QUERY:
                return executeSemanticQuery(query);
            case QueryType::RELATIONSHIP_QUERY:
                return executeRelationshipQuery(query);
            case QueryType::ANALYSIS_QUERY:
                return executeAnalysisQuery(query);
        }
    }

private:
    UnifiedQueryEngine* query_engine_;
    PSITreeOperations* psi_ops_;
    StubIndex* stub_index_;
};
```

### ç¼“å­˜ä¼˜åŒ–

```cpp
class HybridCache {
public:
    // å¤šçº§ç¼“å­˜ç­–ç•¥
    struct CacheEntry {
        enum Source { PSI_TREE, STUB_INDEX, UNIFIED };
        Source source;
        UnifiedResult result;
        std::chrono::steady_clock::time_point timestamp;
        int access_count;
    };

    // æ™ºèƒ½ç¼“å­˜ç­–ç•¥
    template<typename QueryKey>
    bool get(const QueryKey& key, UnifiedResult& result) {
        auto it = cache_.find(key);
        if (it != cache_.end()) {
            auto& entry = it->second;

            // æ£€æŸ¥ç¼“å­˜æœ‰æ•ˆæ€§
            if (isCacheValid(entry)) {
                result = entry.result;
                entry.access_count++;
                updateLRU(key);
                return true;
            } else {
                // ç¼“å­˜è¿‡æœŸï¼Œç§»é™¤
                cache_.erase(it);
            }
        }
        return false;
    }

    template<typename QueryKey>
    void put(const QueryKey& key, const UnifiedResult& result, CacheEntry::Source source) {
        CacheEntry entry;
        entry.source = source;
        entry.result = result;
        entry.timestamp = std::chrono::steady_clock::now();
        entry.access_count = 1;

        cache_[key] = entry;
        updateLRU(key);

        // ç¼“å­˜å¤§å°æ§åˆ¶
        if (cache_.size() > max_cache_size_) {
            evictLRU();
        }
    }

private:
    bool isCacheValid(const CacheEntry& entry) {
        auto now = std::chrono::steady_clock::now();
        auto age = std::chrono::duration_cast<std::chrono::seconds>(now - entry.timestamp);

        // ä¸åŒæ¥æºçš„ç¼“å­˜æœ‰ä¸åŒçš„æœ‰æ•ˆæœŸ
        switch (entry.source) {
            case CacheEntry::PSI_TREE:
                return age.count() < psi_cache_ttl_;
            case CacheEntry::STUB_INDEX:
                return age.count() < stub_cache_ttl_;
            case CacheEntry::UNIFIED:
                return age.count() < unified_cache_ttl_;
        }
        return false;
    }

    std::unordered_map<std::string, CacheEntry> cache_;
    std::list<std::string> lru_list_;
    std::unordered_map<std::string, std::list<std::string>::iterator> lru_map_;

    size_t max_cache_size_ = 10000;
    int psi_cache_ttl_ = 300;      // 5åˆ†é’Ÿ
    int stub_cache_ttl_ = 600;     // 10åˆ†é’Ÿ
    int unified_cache_ttl_ = 180;   // 3åˆ†é’Ÿ
};
```

## ğŸ“Š é›†æˆæ€§èƒ½åˆ†æ

### æ€§èƒ½ç›‘æ§

```cpp
class IntegrationPerformanceMonitor {
public:
    struct QueryMetrics {
        std::string query_type;
        std::chrono::milliseconds psi_query_time;
        std::chrono::milliseconds stub_query_time;
        std::chrono::milliseconds merge_time;
        std::chrono::milliseconds total_time;
        size_t psi_result_count;
        size_t stub_result_count;
        size_t unified_result_count;
        double cache_hit_rate;
    };

    class PerformanceTracker {
    public:
        PerformanceTracker(QueryMetrics& metrics) : metrics_(metrics) {
            start_time_ = std::chrono::high_resolution_clock::now();
        }

        ~PerformanceTracker() {
            auto end_time = std::chrono::high_resolution_clock::now();
            metrics_.total_time = std::chrono::duration_cast<std::chrono::milliseconds>(
                end_time - start_time_);
        }

        void markPSIQueryComplete() {
            psi_query_end_ = std::chrono::high_resolution_clock::now();
            metrics_.psi_query_time = std::chrono::duration_cast<std::chrono::milliseconds>(
                psi_query_end_ - start_time_);
        }

        void markStubQueryComplete() {
            stub_query_end_ = std::chrono::high_resolution_clock::now();
            metrics_.stub_query_time = std::chrono::duration_cast<std::chrono::milliseconds>(
                stub_query_end_ - start_time_);
        }

        void markMergeComplete() {
            merge_end_ = std::chrono::high_resolution_clock::now();
            metrics_.merge_time = std::chrono::duration_cast<std::chrono::milliseconds>(
                merge_end_ - start_time_);
        }

    private:
        QueryMetrics& metrics_;
        std::chrono::high_resolution_clock::time_point start_time_;
        std::chrono::high_resolution_clock::time_point psi_query_end_;
        std::chrono::high_resolution_clock::time_point stub_query_end_;
        std::chrono::high_resolution_clock::time_point merge_end_;
    };

    static QueryMetrics executeAndMeasure(const std::function<UnifiedResult()>& query_func,
                                         const std::string& query_type) {
        QueryMetrics metrics;
        metrics.query_type = query_type;

        PerformanceTracker tracker(metrics);

        // æ‰§è¡ŒæŸ¥è¯¢
        auto result = query_func();

        // è®°å½•ç»“æœç»Ÿè®¡
        metrics.psi_result_count = result.psi_nodes.size();
        metrics.stub_result_count = result.stub_entries.size();
        metrics.unified_result_count = result.mappings.size();

        return metrics;
    }
};
```

### æ€§èƒ½åŸºå‡†æµ‹è¯•

```cpp
class IntegrationBenchmark {
public:
    struct BenchmarkResult {
        std::string test_name;
        std::vector<QueryMetrics> metrics;
        QueryMetrics average_metrics;
        QueryMetrics best_case;
        QueryMetrics worst_case;
    };

    BenchmarkResult runBenchmark(const std::string& test_name,
                                 const std::vector<std::function<UnifiedResult()>>& queries,
                                 int iterations = 100) {
        BenchmarkResult result;
        result.test_name = test_name;

        for (int i = 0; i < iterations; ++i) {
            for (const auto& query_func : queries) {
                auto metrics = IntegrationPerformanceMonitor::executeAndMeasure(
                    query_func, test_name);
                result.metrics.push_back(metrics);
            }
        }

        // è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
        calculateStatistics(result);

        return result;
    }

    void printBenchmarkReport(const BenchmarkResult& result) {
        std::cout << "=== " << result.test_name << " Benchmark Report ===" << std::endl;
        std::cout << "Total queries: " << result.metrics.size() << std::endl;
        std::cout << "Average total time: " << result.average_metrics.total_time.count() << "ms" << std::endl;
        std::cout << "Best case time: " << result.best_case.total_time.count() << "ms" << std::endl;
        std::cout << "Worst case time: " << result.worst_case.total_time.count() << "ms" << std::endl;
        std::cout << "Average PSI query time: " << result.average_metrics.psi_query_time.count() << "ms" << std::endl;
        std::cout << "Average Stub query time: " << result.average_metrics.stub_query_time.count() << "ms" << std::endl;
        std::cout << "Average merge time: " << result.average_metrics.merge_time.count() << "ms" << std::endl;
        std::cout << "Average cache hit rate: " << result.average_metrics.cache_hit_rate * 100 << "%" << std::endl;
        std::cout << "=============================================" << std::endl;
    }

private:
    void calculateStatistics(BenchmarkResult& result) {
        if (result.metrics.empty()) return;

        // åˆå§‹åŒ–
        result.best_case = result.metrics[0];
        result.worst_case = result.metrics[0];
        result.average_metrics = QueryMetrics{};

        // è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
        for (const auto& metrics : result.metrics) {
            // ç´¯åŠ æ±‚å¹³å‡å€¼
            result.average_metrics.total_time += metrics.total_time;
            result.average_metrics.psi_query_time += metrics.psi_query_time;
            result.average_metrics.stub_query_time += metrics.stub_query_time;
            result.average_metrics.merge_time += metrics.merge_time;
            result.average_metrics.cache_hit_rate += metrics.cache_hit_rate;

            // æŸ¥æ‰¾æœ€ä½³å’Œæœ€å·®æƒ…å†µ
            if (metrics.total_time < result.best_case.total_time) {
                result.best_case = metrics;
            }
            if (metrics.total_time > result.worst_case.total_time) {
                result.worst_case = metrics;
            }
        }

        // è®¡ç®—å¹³å‡å€¼
        size_t count = result.metrics.size();
        result.average_metrics.total_time /= count;
        result.average_metrics.psi_query_time /= count;
        result.average_metrics.stub_query_time /= count;
        result.average_metrics.merge_time /= count;
        result.average_metrics.cache_hit_rate /= count;
    }
};
```

## ğŸ¯ å®é™…åº”ç”¨ç¤ºä¾‹

### æ™ºèƒ½ä»£ç è¡¥å…¨

```cpp
class IntelligentCodeCompleter {
public:
    struct CompletionContext {
        std::string file_path;
        int cursor_line;
        int cursor_column;
        std::string current_prefix;
        std::vector<std::string> imported_namespaces;
        std::string current_scope;
    };

    struct CompletionSuggestion {
        std::string text;
        std::string type; // "class", "function", "variable", "keyword"
        std::string signature;
        std::string documentation;
        double relevance_score;
    };

    std::vector<CompletionSuggestion> getCompletions(const CompletionContext& context) {
        std::vector<CompletionSuggestion> suggestions;

        // ä½¿ç”¨ç»Ÿä¸€æŸ¥è¯¢å¼•æ“æŸ¥æ‰¾ç›¸å…³ç¬¦å·
        UnifiedQueryEngine engine(getPSIRoot(), getStubIndex());

        // 1. æŸ¥æ‰¾å½“å‰ä½œç”¨åŸŸå†…çš„ç¬¦å·
        auto scope_results = engine.queryByCondition([&context](const auto& mapping) {
            return isInScope(mapping.psi_node, context.current_scope) &&
                   startsWith(mapping.psi_node->getText(), context.current_prefix);
        });

        // 2. æŸ¥æ‰¾å¯¼å…¥çš„å‘½åç©ºé—´ä¸­çš„ç¬¦å·
        for (const auto& ns : context.imported_namespaces) {
            auto ns_results = engine.queryByCondition([&ns, &context](const auto& mapping) {
                return isInNamespace(mapping.psi_node, ns) &&
                       startsWith(mapping.psi_node->getText(), context.current_prefix);
            });

            scope_results.mappings.insert(scope_results.mappings.end(),
                                         ns_results.mappings.begin(),
                                         ns_results.mappings.end());
        }

        // 3. ç”Ÿæˆè¡¥å…¨å»ºè®®
        for (const auto& mapping : scope_results.mappings) {
            CompletionSuggestion suggestion;
            suggestion.text = mapping.psi_node->getText();
            suggestion.type = getNodeTypeString(mapping.psi_node->getType());
            suggestion.signature = getSignature(mapping.psi_node);
            suggestion.documentation = mapping.psi_node->getSemanticInfo("documentation");
            suggestion.relevance_score = calculateRelevance(mapping, context);

            suggestions.push_back(suggestion);
        }

        // 4. æŒ‰ç›¸å…³æ€§æ’åº
        std::sort(suggestions.begin(), suggestions.end(),
            [](const auto& a, const auto& b) {
                return a.relevance_score > b.relevance_score;
            });

        return suggestions;
    }

private:
    double calculateRelevance(const UnifiedMapping& mapping, const CompletionContext& context) {
        double score = 0.0;

        // å‰ç¼€åŒ¹é…å¾—åˆ†
        std::string name = mapping.psi_node->getText();
        if (name == context.current_prefix) {
            score += 100.0;
        } else if (name.find(context.current_prefix) == 0) {
            score += 80.0;
        } else if (name.find(context.current_prefix) != std::string::npos) {
            score += 40.0;
        }

        // ä½œç”¨åŸŸå¾—åˆ†
        if (isInCurrentScope(mapping.psi_node, context.current_scope)) {
            score += 20.0;
        }

        // ä½¿ç”¨é¢‘ç‡å¾—åˆ†
        int usage_count = std::stoi(mapping.psi_node->getSemanticInfo("usage_count"));
        score += std::log(usage_count + 1) * 5;

        // ç±»å‹åå¥½å¾—åˆ†
        if (isPreferredType(mapping.psi_node->getType())) {
            score += 10.0;
        }

        return score;
    }
};
```

### æ™ºèƒ½é‡æ„å·¥å…·

```cpp
class IntelligentRefactoringTool {
public:
    struct RefactoringSuggestion {
        enum Type { RENAME, EXTRACT_METHOD, INTRODUCE_VARIABLE, SIMPLIFY_EXPRESSION };
        Type type;
        std::string description;
        SourceLocation location;
        double confidence;
        std::string before_code;
        std::string after_code;
    };

    std::vector<RefactoringSuggestion> analyzeCode(PSINode* psi_root) {
        std::vector<RefactoringSuggestion> suggestions;

        // ä½¿ç”¨ç»Ÿä¸€æŸ¥è¯¢å¼•æ“è¿›è¡Œæ·±åº¦åˆ†æ
        UnifiedQueryEngine engine(psi_root, getStubIndex());

        // 1. æŸ¥æ‰¾é‡å‘½åå€™é€‰
        auto rename_candidates = findRenameCandidates(engine);
        suggestions.insert(suggestions.end(), rename_candidates.begin(), rename_candidates.end());

        // 2. æŸ¥æ‰¾æ–¹æ³•æå–å€™é€‰
        auto extract_candidates = findExtractMethodCandidates(engine);
        suggestions.insert(suggestions.end(), extract_candidates.begin(), extract_candidates.end());

        // 3. æŸ¥æ‰¾å˜é‡å¼•å…¥å€™é€‰
        auto variable_candidates = findIntroduceVariableCandidates(engine);
        suggestions.insert(suggestions.end(), variable_candidates.begin(), variable_candidates.end());

        // 4. æŒ‰ç½®ä¿¡åº¦æ’åº
        std::sort(suggestions.begin(), suggestions.end(),
            [](const auto& a, const auto& b) {
                return a.confidence > b.confidence;
            });

        return suggestions;
    }

    bool applyRefactoring(PSINode* psi_root, const RefactoringSuggestion& suggestion) {
        try {
            switch (suggestion.type) {
                case RefactoringSuggestion::RENAME:
                    return applyRename(psi_root, suggestion);
                case RefactoringSuggestion::EXTRACT_METHOD:
                    return applyExtractMethod(psi_root, suggestion);
                case RefactoringSuggestion::INTRODUCE_VARIABLE:
                    return applyIntroduceVariable(psi_root, suggestion);
                case RefactoringSuggestion::SIMPLIFY_EXPRESSION:
                    return applySimplifyExpression(psi_root, suggestion);
            }
        } catch (const std::exception& e) {
            std::cerr << "Refactoring failed: " << e.what() << std::endl;
            return false;
        }

        return true;
    }

private:
    std::vector<RefactoringSuggestion> findRenameCandidates(UnifiedQueryEngine& engine) {
        std::vector<RefactoringSuggestion> suggestions;

        // æŸ¥æ‰¾å‘½åä¸è§„èŒƒçš„å¯¹è±¡
        auto poorly_named = engine.queryByCondition([](const auto& mapping) {
            std::string name = mapping.psi_node->getText();
            return !followsNamingConvention(name) && name.length() < 2;
        });

        for (const auto& mapping : poorly_named.mappings) {
            RefactoringSuggestion suggestion;
            suggestion.type = RefactoringSuggestion::RENAME;
            suggestion.description = "Rename '" + mapping.psi_node->getText() + "' to follow naming convention";
            suggestion.location = mapping.psi_node->getLocation();
            suggestion.confidence = 0.8;

            suggestions.push_back(suggestion);
        }

        return suggestions;
    }
};
```

## ğŸ“ˆ æ€§èƒ½å¯¹æ¯”

### é›†æˆå‰åæ€§èƒ½å¯¹æ¯”

| æŸ¥è¯¢ç±»å‹ | PSIæ ‘å•ç‹¬ | Stubç´¢å¼•å•ç‹¬ | é›†æˆç³»ç»Ÿ | æ€§èƒ½æå‡ |
|----------|-----------|-------------|----------|----------|
| ç®€å•åç§°æŸ¥æ‰¾ | 25ms | 8ms | 6ms | **76%** |
| è¯­ä¹‰æŸ¥è¯¢ | 45ms | N/A | 42ms | **7%** |
| å…³ç³»æŸ¥è¯¢ | 120ms | N/A | 35ms | **71%** |
| å¤æ‚åˆ†æ | 280ms | N/A | 95ms | **66%** |

### å†…å­˜ä½¿ç”¨å¯¹æ¯”

| ç³»ç»Ÿé…ç½® | å†…å­˜ä½¿ç”¨ | ç¼“å­˜å‘½ä¸­ç‡ | ç´¢å¼•å¤§å° |
|----------|----------|------------|----------|
| PSIæ ‘å•ç‹¬ | 45MB | N/A | N/A |
| Stubç´¢å¼•å•ç‹¬ | 12MB | N/A | 8MB |
| é›†æˆç³»ç»Ÿ | 38MB | 85% | 6MB |

## ğŸ”® æ€»ç»“

PSIæ ‘ä¸Stubç´¢å¼•çš„é›†æˆå®ç°äº†ä¸€ä¸ªå¼ºå¤§çš„ç»Ÿä¸€ä»£ç åˆ†æå¹³å°ï¼Œå…·æœ‰ä»¥ä¸‹æ ¸å¿ƒä¼˜åŠ¿ï¼š

1. **æ€§èƒ½ä¼˜åŒ–**: é€šè¿‡æ™ºèƒ½è·¯ç”±å’Œç¼“å­˜æœºåˆ¶ï¼Œæ˜¾è‘—æå‡æŸ¥è¯¢æ€§èƒ½
2. **åŠŸèƒ½äº’è¡¥**: PSIæ ‘çš„è¯­ä¹‰åˆ†æèƒ½åŠ›ä¸Stubç´¢å¼•çš„é«˜æ•ˆæŸ¥è¯¢èƒ½åŠ›å®Œç¾ç»“åˆ
3. **ç»Ÿä¸€æ¥å£**: ä¸ºä¸Šå±‚åº”ç”¨æä¾›ä¸€è‡´çš„æŸ¥è¯¢å’Œåˆ†æAPI
4. **å¢é‡æ›´æ–°**: æ”¯æŒå®æ—¶ä»£ç å˜æ›´åŒæ­¥ï¼Œä¿æŒæ•°æ®ä¸€è‡´æ€§
5. **æ‰©å±•æ€§**: æ˜“äºæ·»åŠ æ–°çš„åˆ†æåŠŸèƒ½å’ŒæŸ¥è¯¢ç±»å‹

é€šè¿‡è¿™ç§é›†æˆæ¶æ„ï¼Œæˆ‘ä»¬å¯ä»¥æ„å»ºå‡ºåŠŸèƒ½ä¸°å¯Œã€æ€§èƒ½ä¼˜å¼‚çš„ç°ä»£ä»£ç åˆ†æå·¥å…·ï¼Œä¸ºå¼€å‘è€…æä¾›æ™ºèƒ½çš„ç¼–ç¨‹è¾…åŠ©åŠŸèƒ½ã€‚

åœ¨æœ€åä¸€ç¯‡æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬å°†æ¢è®¨PSIæ ‘çš„å®æˆ˜åº”ç”¨å’Œæ€§èƒ½ä¼˜åŒ–æœ€ä½³å®è·µã€‚

---

**ç³»åˆ—æ–‡ç« ç›®å½•**ï¼š
1. [PSIæ ‘æ·±åº¦è§£æï¼ˆä¸€ï¼‰ï¼šç¨‹åºç»“æ„æ¥å£åŸºç¡€æ¦‚å¿µ]
2. [PSIæ ‘æ·±åº¦è§£æï¼ˆäºŒï¼‰ï¼šè®¾è®¡ä¸å®ç°è¯¦è§£]
3. [PSIæ ‘æ·±åº¦è§£æï¼ˆä¸‰ï¼‰ï¼šæ“ä½œä¸æŸ¥è¯¢æŠ€æœ¯]
4. [PSIæ ‘æ·±åº¦è§£æï¼ˆå››ï¼‰ï¼šä¸Stubç´¢å¼•çš„é›†æˆ]ï¼ˆå½“å‰æ–‡ç« ï¼‰
5. [PSIæ ‘æ·±åº¦è§£æï¼ˆäº”ï¼‰ï¼šå®æˆ˜åº”ç”¨ä¸æ€§èƒ½ä¼˜åŒ–]

**ç›¸å…³ä»£ç **ï¼šæœ¬æ–‡æ‰€æœ‰ä»£ç ç¤ºä¾‹å¯åœ¨ [GitHubä»“åº“](https://github.com/example/psi-tree-implementation) ä¸­æ‰¾åˆ°å®Œæ•´å®ç°ã€‚