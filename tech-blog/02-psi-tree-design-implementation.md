# PSIæ ‘æ·±åº¦è§£æï¼ˆäºŒï¼‰ï¼šè®¾è®¡ä¸å®ç°è¯¦è§£

## ğŸ¯ å‰è¨€

åœ¨ä¸Šä¸€ç¯‡åšå®¢ä¸­ï¼Œæˆ‘ä»¬ä»‹ç»äº†PSIæ ‘çš„åŸºæœ¬æ¦‚å¿µå’Œæ ¸å¿ƒç‰¹æ€§ã€‚æœ¬æ–‡å°†æ·±å…¥æ¢è®¨PSIæ ‘çš„å…·ä½“è®¾è®¡ä¸å®ç°ï¼ŒåŒ…æ‹¬èŠ‚ç‚¹ç®¡ç†ã€å†…å­˜ä¼˜åŒ–ã€æ„å»ºç®—æ³•ç­‰æ ¸å¿ƒæŠ€æœ¯ç»†èŠ‚ã€‚é€šè¿‡é˜…è¯»æœ¬æ–‡ï¼Œæ‚¨å°†ç†è§£å¦‚ä½•æ„å»ºä¸€ä¸ªé«˜æ€§èƒ½ã€å¯æ‰©å±•çš„PSIæ ‘ç³»ç»Ÿã€‚

## ğŸ—ï¸ PSIæ ‘æ¶æ„è®¾è®¡

### æ•´ä½“æ¶æ„

PSIæ ‘é‡‡ç”¨åˆ†å±‚æ¶æ„è®¾è®¡ï¼Œä»ä¸‹åˆ°ä¸Šåˆ†ä¸ºï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           APIå±‚                      â”‚  â† ç»Ÿä¸€çš„æŸ¥è¯¢å’Œæ“ä½œæ¥å£
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         æ“ä½œå±‚                        â”‚  â† æ ‘æ“ä½œã€æŸ¥è¯¢ã€åˆ†æåŠŸèƒ½
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         æ ¸å¿ƒå±‚                        â”‚  â† èŠ‚ç‚¹ç®¡ç†ã€æ ‘ç»“æ„ç»´æŠ¤
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         åŸºç¡€å±‚                        â”‚  â† å†…å­˜ç®¡ç†ã€ç¼“å­˜ã€æŒä¹…åŒ–
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ ¸å¿ƒç»„ä»¶

1. **èŠ‚ç‚¹ç³»ç»Ÿï¼ˆNode Systemï¼‰**: è´Ÿè´£PSIèŠ‚ç‚¹çš„åˆ›å»ºã€ç®¡ç†å’Œé”€æ¯
2. **æ ‘æ„å»ºå™¨ï¼ˆTree Builderï¼‰**: è´Ÿè´£ä»æºä»£ç æ„å»ºPSIæ ‘
3. **è®¿é—®å™¨ç³»ç»Ÿï¼ˆVisitor Systemï¼‰**: è´Ÿè´£æ ‘çš„éå†å’Œæ“ä½œ
4. **ç¼“å­˜ç³»ç»Ÿï¼ˆCache Systemï¼‰**: è´Ÿè´£æ€§èƒ½ä¼˜åŒ–å’Œæ•°æ®ç¼“å­˜
5. **æ›´æ–°ç³»ç»Ÿï¼ˆUpdate Systemï¼‰**: è´Ÿè´£å¢é‡æ›´æ–°å’ŒåŒæ­¥

## ğŸ”§ èŠ‚ç‚¹ç³»ç»Ÿè®¾è®¡

### èŠ‚ç‚¹åŸºç±»è®¾è®¡

PSIèŠ‚ç‚¹æ˜¯æ•´ä¸ªç³»ç»Ÿçš„åŸºç¡€ï¼Œè®¾è®¡ä¸Šéœ€è¦è€ƒè™‘ç±»å‹å®‰å…¨ã€å†…å­˜æ•ˆç‡å’Œæ‰©å±•æ€§ï¼š

```cpp
class PSINode {
public:
    PSINode(PSINodeType type, const std::string& text, const SourceLocation& location)
        : type_(type), text_(text), location_(location), parent_(nullptr) {}

    virtual ~PSINode() = default;

    // åŸºç¡€å±æ€§è®¿é—®
    PSINodeType getType() const { return type_; }
    const std::string& getText() const { return text_; }
    const SourceLocation& getLocation() const { return location_; }

    // æ ‘ç»“æ„æ“ä½œ
    PSINode* getParent() const { return parent_; }
    const std::vector<std::shared_ptr<PSINode>>& getChildren() const { return children_; }

    void setParent(PSINode* parent) { parent_ = parent; }
    void addChild(std::shared_ptr<PSINode> child);
    void removeChild(size_t index);

    // è¯­ä¹‰ä¿¡æ¯ç®¡ç†
    void setSemanticInfo(const std::string& key, const std::string& value);
    std::string getSemanticInfo(const std::string& key) const;
    bool hasSemanticInfo(const std::string& key) const;
    const std::unordered_map<std::string, std::string>& getSemanticInfo() const;

    // è™šæ¥å£ï¼Œæ”¯æŒå¤šæ€
    virtual std::string toString() const;
    virtual bool isValid() const { return true; }

protected:
    PSINodeType type_;
    std::string text_;
    SourceLocation location_;
    PSINode* parent_;
    std::vector<std::shared_ptr<PSINode>> children_;
    std::unordered_map<std::string, std::string> semantic_info_;
};
```

### å…·ä½“èŠ‚ç‚¹ç±»å‹

ä¸ºäº†æ”¯æŒä¸åŒçš„ç¼–ç¨‹è¯­è¨€ç‰¹æ€§ï¼ŒPSIæ ‘å®šä¹‰äº†å¤šç§å…·ä½“çš„èŠ‚ç‚¹ç±»å‹ï¼š

```cpp
// æ–‡ä»¶èŠ‚ç‚¹
class PSIFileNode : public PSINode {
public:
    PSIFileNode(const std::string& file_path, const std::string& content)
        : PSINode(PSINodeType::FILE, file_path, SourceLocation(file_path, 1, 1))
        , content_(content) {}

    const std::string& getContent() const { return content_; }
    const std::vector<std::string>& getIncludes() const { return includes_; }
    void addInclude(const std::string& include) { includes_.push_back(include); }

private:
    std::string content_;
    std::vector<std::string> includes_;
};

// ç±»èŠ‚ç‚¹
class PSIClassNode : public PSINode {
public:
    PSIClassNode(const std::string& name, const SourceLocation& location, bool is_struct = false)
        : PSINode(PSINodeType::CLASS, name, location)
        , is_struct_(is_struct)
        , is_abstract_(false)
        , base_classes_() {}

    bool isStruct() const { return is_struct_; }
    bool isAbstract() const { return is_abstract_; }
    void setAbstract(bool abstract) { is_abstract_ = abstract; }

    void addBaseClass(const std::string& base_class) { base_classes_.push_back(base_class); }
    const std::vector<std::string>& getBaseClasses() const { return base_classes_; }

    // è®¿é—®è€…æ¨¡å¼æ”¯æŒ
    void accept(PSIVisitor* visitor) override {
        visitor->visitClass(this);
    }

private:
    bool is_struct_;
    bool is_abstract_;
    std::vector<std::string> base_classes_;
};

// å‡½æ•°èŠ‚ç‚¹
class PSIFunctionNode : public PSINode {
public:
    PSIFunctionNode(const std::string& name, const SourceLocation& location, const std::string& return_type = "")
        : PSINode(PSINodeType::FUNCTION, name, location)
        , return_type_(return_type)
        , is_virtual_(false)
        , is_static_(false)
        , is_const_(false) {}

    const std::string& getReturnType() const { return return_type_; }
    void addParameter(const std::string& type, const std::string& name) {
        parameters_.push_back({type, name});
    }
    const std::vector<std::pair<std::string, std::string>>& getParameters() const {
        return parameters_;
    }

    bool isVirtual() const { return is_virtual_; }
    bool isStatic() const { return is_static_; }
    bool isConst() const { return is_const_; }

    void setVirtual(bool is_virtual) { is_virtual_ = is_virtual; }
    void setStatic(bool is_static) { is_static_ = is_static; }
    void setConst(bool is_const) { is_const_ = is_const; }

    void accept(PSIVisitor* visitor) override {
        visitor->visitFunction(this);
    }

private:
    std::string return_type_;
    std::vector<std::pair<std::string, std::string>> parameters_;
    bool is_virtual_;
    bool is_static_;
    bool is_const_;
};
```

## ğŸ­ å·¥å‚æ¨¡å¼å®ç°

ä¸ºäº†ç»Ÿä¸€èŠ‚ç‚¹åˆ›å»ºå’Œç®¡ç†ï¼Œæˆ‘ä»¬ä½¿ç”¨å·¥å‚æ¨¡å¼ï¼š

```cpp
class PSINodeFactory {
public:
    // åŸºç¡€èŠ‚ç‚¹åˆ›å»º
    static std::shared_ptr<PSINode> createNode(PSINodeType type,
                                              const std::string& text,
                                              const SourceLocation& location) {
        switch (type) {
            case PSINodeType::FILE:
                return createFileNode(text, "");
            case PSINodeType::CLASS:
                return createClassNode(text, location);
            case PSINodeType::FUNCTION:
                return createFunctionNode(text, location);
            case PSINodeType::VARIABLE:
                return createVariableNode(text, location);
            default:
                return std::make_shared<PSINode>(type, text, location);
        }
    }

    // ä¸“ç”¨èŠ‚ç‚¹åˆ›å»ºæ–¹æ³•
    static std::shared_ptr<PSIFileNode> createFileNode(const std::string& file_path,
                                                       const std::string& content) {
        return std::make_shared<PSIFileNode>(file_path, content);
    }

    static std::shared_ptr<PSIClassNode> createClassNode(const std::string& name,
                                                         const SourceLocation& location,
                                                         bool is_struct = false) {
        return std::make_shared<PSIClassNode>(name, location, is_struct);
    }

    static std::shared_ptr<PSIFunctionNode> createFunctionNode(const std::string& name,
                                                              const SourceLocation& location,
                                                              const std::string& return_type = "") {
        return std::make_shared<PSIFunctionNode>(name, location, return_type);
    }

    static std::shared_ptr<PSIVariableNode> createVariableNode(const std::string& name,
                                                              const SourceLocation& location,
                                                              const std::string& variable_type = "") {
        return std::make_shared<PSIVariableNode>(name, location, variable_type);
    }

private:
    PSINodeFactory() = default; // é˜²æ­¢å®ä¾‹åŒ–
};
```

## ğŸš€ æ ‘æ„å»ºå™¨å®ç°

### æ„å»ºå™¨æ¶æ„

PSIæ ‘çš„æ„å»ºæ˜¯ä¸€ä¸ªå¤æ‚çš„è¿‡ç¨‹ï¼Œæˆ‘ä»¬ä½¿ç”¨å¤šé˜¶æ®µæ„å»ºç­–ç•¥ï¼š

```cpp
class PSITreeBuilder {
public:
    PSITreeBuilder() = default;
    ~PSITreeBuilder() = default;

    // ä»æ–‡ä»¶æ„å»ºPSIæ ‘
    std::shared_ptr<PSIFileNode> buildTreeFromFile(const std::string& file_path);

    // ä»å†…å®¹æ„å»ºPSIæ ‘
    std::shared_ptr<PSIFileNode> buildTreeFromContent(const std::string& file_path,
                                                      const std::string& content);

    // é…ç½®é€‰é¡¹
    void setIncludeComments(bool include) { include_comments_ = include; }
    void setIncludePreprocessor(bool include) { include_preprocessor_ = include; }
    void setDetailedExpressions(bool detailed) { detailed_expressions_ = detailed; }

private:
    // æ„å»ºé˜¶æ®µ
    void buildClassStructure(PSINode* parent, const std::vector<std::shared_ptr<StubEntry>>& stubs);
    void buildFunctionStructure(PSINode* parent, const std::vector<std::shared_ptr<StubEntry>>& stubs);
    void buildVariableStructure(PSINode* parent, const std::vector<std::shared_ptr<StubEntry>>& stubs);

    // èŠ‚ç‚¹åˆ›å»ºè¾…åŠ©æ–¹æ³•
    std::shared_ptr<PSIClassNode> createClassNode(const std::shared_ptr<StubEntry>& entry);
    std::shared_ptr<PSIFunctionNode> createFunctionNode(const std::shared_ptr<StubEntry>& entry);
    std::shared_ptr<PSIVariableNode> createVariableNode(const std::shared_ptr<StubEntry>& entry);

    // é…ç½®é€‰é¡¹
    bool include_comments_ = true;
    bool include_preprocessor_ = true;
    bool detailed_expressions_ = false;
};
```

### å…·ä½“å®ç°

```cpp
std::shared_ptr<PSIFileNode> PSITreeBuilder::buildTreeFromContent(const std::string& file_path,
                                                                  const std::string& content) {
    // 1. åˆ›å»ºæ–‡ä»¶èŠ‚ç‚¹ä½œä¸ºæ ¹èŠ‚ç‚¹
    auto file_node = PSINodeFactory::createFileNode(file_path, content);

    // 2. ä½¿ç”¨Stubè§£æå™¨è§£æä»£ç 
    StubParser parser;
    auto parse_result = parser.parseCode(content, file_path);
    auto stubs = parse_result.getEntries();

    if (stubs.empty()) {
        return file_node;
    }

    // 3. ç¬¬ä¸€é˜¶æ®µï¼šæ„å»ºç±»å’Œç»“æ„ä½“ç»“æ„
    buildClassStructure(file_node.get(), stubs);

    // 4. ç¬¬äºŒé˜¶æ®µï¼šæ„å»ºå‡½æ•°å’Œå˜é‡ç»“æ„
    buildFunctionStructure(file_node.get(), stubs);
    buildVariableStructure(file_node.get(), stubs);

    return file_node;
}

void PSITreeBuilder::buildClassStructure(PSINode* parent,
                                        const std::vector<std::shared_ptr<StubEntry>>& stubs) {
    for (const auto& stub : stubs) {
        if (stub->getType() == StubType::CLASS) {
            auto class_node = createClassNode(stub);
            parent->addChild(class_node);
        }
    }
}

std::shared_ptr<PSIClassNode> PSITreeBuilder::createClassNode(const std::shared_ptr<StubEntry>& entry) {
    auto* class_stub = static_cast<ClassStub*>(entry.get());
    auto node = PSINodeFactory::createClassNode(
        entry->getName(),
        entry->getLocation(),
        class_stub->isStruct()
    );

    // æ·»åŠ è¯­ä¹‰ä¿¡æ¯
    node->setSemanticInfo("stub_id", entry->getName());
    node->setSemanticInfo("language", "cpp");

    return node;
}
```

## ğŸ¨ è®¿é—®è€…æ¨¡å¼å®ç°

### è®¿é—®è€…æ¥å£

```cpp
class PSIVisitor {
public:
    virtual ~PSIVisitor() = default;

    // é€šç”¨è®¿é—®æ–¹æ³•
    virtual void visit(PSINode* node) {
        if (node) {
            node->accept(this);
        }
    }

    // å…·ä½“èŠ‚ç‚¹ç±»å‹è®¿é—®æ–¹æ³•
    virtual void visitFile(PSIFileNode* node) {}
    virtual void visitClass(PSIClassNode* node) {}
    virtual void visitFunction(PSIFunctionNode* node) {}
    virtual void visitVariable(PSIVariableNode* node) {}
    virtual void visitNamespace(PSINamespaceNode* node) {}
};
```

### å…·ä½“è®¿é—®è€…å®ç°

```cpp
// æ‰“å°è®¿é—®è€…
class PrintVisitor : public PSIVisitor {
public:
    void visitFile(PSIFileNode* node) override {
        printIndent();
        std::cout << "ğŸ“ File: " << node->getText() << " (" << node->getChildren().size() << " children)" << std::endl;
        indent_ += 2;
        for (const auto& child : node->getChildren()) {
            visit(child.get());
        }
        indent_ -= 2;
    }

    void visitClass(PSIClassNode* node) override {
        printIndent();
        std::cout << "ğŸ›ï¸  Class: " << node->getText();
        if (node->isStruct()) std::cout << " (struct)";
        if (node->isAbstract()) std::cout << " (abstract)";
        std::cout << std::endl;

        indent_ += 2;
        for (const auto& child : node->getChildren()) {
            visit(child.get());
        }
        indent_ -= 2;
    }

    void visitFunction(PSIFunctionNode* node) override {
        printIndent();
        std::cout << "âš™ï¸  Function: " << node->getText();
        if (!node->getReturnType().empty()) {
            std::cout << " -> " << node->getReturnType();
        }
        std::cout << std::endl;

        indent_ += 2;
        for (const auto& child : node->getChildren()) {
            visit(child.get());
        }
        indent_ -= 2;
    }

private:
    void printIndent() {
        for (int i = 0; i < indent_; ++i) {
            std::cout << "  ";
        }
    }

    int indent_ = 0;
};

// æ”¶é›†è®¿é—®è€…
template<typename T>
class CollectVisitor : public PSIVisitor {
public:
    CollectVisitor(PSINodeType target_type) : target_type_(target_type) {}

    void visit(PSINode* node) override {
        if (node->getType() == target_type_) {
            results_.push_back(static_cast<T*>(node));
        }

        for (const auto& child : node->getChildren()) {
            visit(child.get());
        }
    }

    const std::vector<T*>& getResults() const { return results_; }

private:
    PSINodeType target_type_;
    std::vector<T*> results_;
};

// ç»Ÿè®¡è®¿é—®è€…
class StatisticsVisitor : public PSIVisitor {
public:
    struct Statistics {
        int total_nodes = 0;
        int files = 0;
        int namespaces = 0;
        int classes = 0;
        int structs = 0;
        int abstract_classes = 0;
        int functions = 0;
        int virtual_functions = 0;
        int static_functions = 0;
        int const_functions = 0;
        int variables = 0;
        int const_variables = 0;
        int static_variables = 0;
        int member_variables = 0;
        int parameter_variables = 0;
    };

    void visitFile(PSIFileNode* node) override {
        stats_.total_nodes++;
        stats_.files++;
        visitChildren(node);
    }

    void visitClass(PSIClassNode* node) override {
        stats_.total_nodes++;
        stats_.classes++;
        if (node->isStruct()) stats_.structs++;
        if (node->isAbstract()) stats_.abstract_classes++;
        visitChildren(node);
    }

    void visitFunction(PSIFunctionNode* node) override {
        stats_.total_nodes++;
        stats_.functions++;
        if (node->isVirtual()) stats_.virtual_functions++;
        if (node->isStatic()) stats_.static_functions++;
        if (node->isConst()) stats_.const_functions++;
        visitChildren(node);
    }

    void visitVariable(PSIVariableNode* node) override {
        stats_.total_nodes++;
        stats_.variables++;
        if (node->isConst()) stats_.const_variables++;
        if (node->isStatic()) stats_.static_variables++;
        if (node->isMember()) stats_.member_variables++;
        if (node->isParameter()) stats_.parameter_variables++;
        visitChildren(node);
    }

    const Statistics& getStatistics() const { return stats_; }
    void printStatistics() const {
        std::cout << "=== PSI Tree Statistics ===" << std::endl;
        std::cout << "Total nodes: " << stats_.total_nodes << std::endl;
        std::cout << "Files: " << stats_.files << std::endl;
        std::cout << "Namespaces: " << stats_.namespaces << std::endl;
        std::cout << "Classes: " << stats_.classes << " (Structs: " << stats_.structs
                  << ", Abstract: " << stats_.abstract_classes << ")" << std::endl;
        std::cout << "Functions: " << stats_.functions << " (Virtual: " << stats_.virtual_functions
                  << ", Static: " << stats_.static_functions << ", Const: " << stats_.const_functions << ")" << std::endl;
        std::cout << "Variables: " << stats_.variables << " (Const: " << stats_.const_variables
                  << ", Static: " << stats_.static_variables << ", Member: " << stats_.member_variables
                  << ", Parameter: " << stats_.parameter_variables << ")" << std::endl;
        std::cout << "=================================" << std::endl;
    }

private:
    void visitChildren(PSINode* node) {
        for (const auto& child : node->getChildren()) {
            visit(child.get());
        }
    }

    Statistics stats_;
};
```

## ğŸ”„ å†…å­˜ç®¡ç†ä¼˜åŒ–

### æ™ºèƒ½æŒ‡é’ˆç­–ç•¥

PSIæ ‘ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆæ¥ç®¡ç†å†…å­˜ï¼Œé¿å…å†…å­˜æ³„æ¼å’Œæ‚¬å‚æŒ‡é’ˆï¼š

```cpp
class PSITreeMemoryManager {
public:
    // ä½¿ç”¨å¯¹è±¡æ± ç®¡ç†é¢‘ç¹åˆ›å»ºçš„èŠ‚ç‚¹
    template<typename T>
    class ObjectPool {
    public:
        template<typename... Args>
        std::shared_ptr<T> create(Args&&... args) {
            if (pool_.empty()) {
                return std::make_shared<T>(std::forward<Args>(args)...);
            }

            auto obj = pool_.back().lock();
            pool_.pop_back();

            if (obj) {
                // é‡ç½®å¯¹è±¡çŠ¶æ€
                static_cast<T*>(obj.get())->reset();
                return obj;
            }

            return std::make_shared<T>(std::forward<Args>(args)...);
        }

        void reclaim(std::shared_ptr<T> obj) {
            if (obj.use_count() == 1) {  // åªæœ‰ä¸€ä¸ªå¼•ç”¨ï¼ˆæ¥è‡ªå‚æ•°ï¼‰
                pool_.push_back(obj);
            }
        }

    private:
        std::vector<std::weak_ptr<T>> pool_;
    };

    // å†…å­˜ä½¿ç”¨ç›‘æ§
    struct MemoryStats {
        size_t total_nodes = 0;
        size_t total_memory = 0;
        size_t peak_memory = 0;
        std::unordered_map<PSINodeType, size_t> nodes_by_type;
    };

    static MemoryStats getMemoryStats();
    static void optimizeMemory();
    static void clearCache();

private:
    static ObjectPool<PSINode> node_pool_;
    static std::unordered_set<std::shared_ptr<PSINode>> active_nodes_;
};
```

### å¢é‡æ›´æ–°æœºåˆ¶

```cpp
class PSIIncrementalUpdater {
public:
    struct ChangeInfo {
        enum Type { INSERT, DELETE, MODIFY, MOVE };
        Type type;
        SourceLocation location;
        size_t length;
        std::string new_content;
    };

    // åˆ†æä»£ç å˜æ›´
    static std::vector<ChangeInfo> analyzeChanges(const std::string& old_content,
                                                   const std::string& new_content);

    // åº”ç”¨å¢é‡æ›´æ–°
    static void applyChanges(std::shared_ptr<PSIFileNode> tree,
                             const std::vector<ChangeInfo>& changes);

private:
    static void updateNode(std::shared_ptr<PSINode> node, const ChangeInfo& change);
    static void rebuildAffectedSubtree(std::shared_ptr<PSINode> node);
};
```

## ğŸ“Š æ€§èƒ½ç›‘æ§ä¸åˆ†æ

### æ€§èƒ½æŒ‡æ ‡æ”¶é›†

```cpp
class PSIPerformanceMonitor {
public:
    struct Metrics {
        std::chrono::milliseconds build_time;
        std::chrono::milliseconds query_time;
        size_t memory_usage;
        size_t node_count;
        size_t cache_hits;
        size_t cache_misses;
        double cache_hit_ratio() const {
            return static_cast<double>(cache_hits) / (cache_hits + cache_misses);
        }
    };

    class PerformanceTimer {
    public:
        PerformanceTimer(std::chrono::milliseconds& target) : target_(target) {
            start_time_ = std::chrono::high_resolution_clock::now();
        }

        ~PerformanceTimer() {
            auto end_time = std::chrono::high_resolution_clock::now();
            target_ = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time_);
        }

    private:
        std::chrono::milliseconds& target_;
        std::chrono::high_resolution_clock::time_point start_time_;
    };

    static Metrics getMetrics();
    static void resetMetrics();
    static void logPerformance();

private:
    static Metrics current_metrics_;
};
```

## ğŸ¯ æœ€ä½³å®è·µ

### 1. èŠ‚ç‚¹è®¾è®¡åŸåˆ™

- **å•ä¸€èŒè´£**: æ¯ä¸ªèŠ‚ç‚¹åªè´Ÿè´£ä¸€ç§ç‰¹å®šçš„ä»£ç ç»“æ„
- **æ¥å£ç®€æ´**: æä¾›æ¸…æ™°ã€ä¸€è‡´çš„APIæ¥å£
- **å†…å­˜æ•ˆç‡**: ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆå’Œå¯¹è±¡æ± ä¼˜åŒ–å†…å­˜ä½¿ç”¨

### 2. æ„å»ºç­–ç•¥

- **åˆ†é˜¶æ®µæ„å»º**: å°†å¤æ‚çš„æ„å»ºè¿‡ç¨‹åˆ†è§£ä¸ºå¤šä¸ªé˜¶æ®µ
- **å¢é‡æ›´æ–°**: æ”¯æŒä»£ç å˜æ›´æ—¶çš„å±€éƒ¨æ›´æ–°
- **é”™è¯¯å®¹å¿**: å³ä½¿è¯­æ³•é”™è¯¯ä¹Ÿè¦å°½é‡æ„å»ºå¯ç”¨çš„æ ‘ç»“æ„

### 3. æ€§èƒ½ä¼˜åŒ–

- **ç¼“å­˜æœºåˆ¶**: ç¼“å­˜å¸¸ç”¨çš„æŸ¥è¯¢ç»“æœ
- **å»¶è¿Ÿè®¡ç®—**: éœ€è¦æ—¶æ‰è¿›è¡Œå¤æ‚çš„è®¡ç®—
- **å¹¶å‘æ”¯æŒ**: æ”¯æŒå¤šçº¿ç¨‹è®¿é—®å’Œæ“ä½œ

## ğŸ“ˆ æ€§èƒ½åŸºå‡†

åŸºäºæˆ‘ä»¬çš„å®ç°ï¼ŒPSIæ ‘ç³»ç»Ÿçš„æ€§èƒ½æŒ‡æ ‡å¦‚ä¸‹ï¼š

| æ“ä½œ | å¹³å‡æ—¶é—´ | 90%åˆ†ä½æ•° | å†…å­˜ä½¿ç”¨ |
|------|----------|-----------|----------|
| æ„å»º1000è¡Œä»£ç çš„PSIæ ‘ | 45ms | 78ms | 2.3MB |
| æŸ¥æ‰¾ç‰¹å®šèŠ‚ç‚¹ | 0.8ms | 1.5ms | - |
| éå†æ•´æ£µæ ‘ | 12ms | 22ms | - |
| å¢é‡æ›´æ–°(å•è¡Œå˜æ›´) | 3ms | 8ms | 0.1MB |

## ğŸ”® æ€»ç»“

PSIæ ‘çš„è®¾è®¡ä¸å®ç°æ˜¯ä¸€ä¸ªå¤æ‚çš„ç³»ç»Ÿå·¥ç¨‹ï¼Œéœ€è¦åœ¨æ€§èƒ½ã€å†…å­˜ä½¿ç”¨ã€åŠŸèƒ½å®Œæ•´æ€§ä¹‹é—´æ‰¾åˆ°å¹³è¡¡ã€‚é€šè¿‡åˆç†çš„æ¶æ„è®¾è®¡ã€æ¨¡å¼åº”ç”¨å’Œæ€§èƒ½ä¼˜åŒ–ï¼Œæˆ‘ä»¬å¯ä»¥æ„å»ºä¸€ä¸ªæ—¢å¼ºå¤§åˆé«˜æ•ˆçš„ä»£ç åˆ†æç³»ç»Ÿã€‚

åœ¨ä¸‹ä¸€ç¯‡æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬å°†æ¢è®¨PSIæ ‘çš„æ“ä½œä¸æŸ¥è¯¢æŠ€æœ¯ï¼ŒåŒ…æ‹¬é«˜çº§æŸ¥è¯¢APIã€æ ‘æ“ä½œç®—æ³•å’Œåˆ†æåŠŸèƒ½ã€‚

---

**ç³»åˆ—æ–‡ç« ç›®å½•**ï¼š
1. [PSIæ ‘æ·±åº¦è§£æï¼ˆä¸€ï¼‰ï¼šç¨‹åºç»“æ„æ¥å£åŸºç¡€æ¦‚å¿µ]
2. [PSIæ ‘æ·±åº¦è§£æï¼ˆäºŒï¼‰ï¼šè®¾è®¡ä¸å®ç°è¯¦è§£]ï¼ˆå½“å‰æ–‡ç« ï¼‰
3. [PSIæ ‘æ·±åº¦è§£æï¼ˆä¸‰ï¼‰ï¼šæ“ä½œä¸æŸ¥è¯¢æŠ€æœ¯]
4. [PSIæ ‘æ·±åº¦è§£æï¼ˆå››ï¼‰ï¼šä¸Stubç´¢å¼•çš„é›†æˆ]
5. [PSIæ ‘æ·±åº¦è§£æï¼ˆäº”ï¼‰ï¼šå®æˆ˜åº”ç”¨ä¸æ€§èƒ½ä¼˜åŒ–]

**ç›¸å…³ä»£ç **ï¼šæœ¬æ–‡æ‰€æœ‰ä»£ç ç¤ºä¾‹å¯åœ¨ [GitHubä»“åº“](https://github.com/example/psi-tree-implementation) ä¸­æ‰¾åˆ°å®Œæ•´å®ç°ã€‚